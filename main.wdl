version 1.0

## MAD4HatTeR Main Workflow
##
## This is the main workflow for MAD4HatTeR (Malaria Amplicon Deep-sequencing for Haplotype and Target Resistance)
## pipeline. It processes amplicon sequencing data through demultiplexing, denoising, quality control,
## and resistance marker analysis.
##
## The workflow supports three main modes:
## 1. complete - Full pipeline from raw reads to final results (default)
## 2. qc - Quality control only
## 3. postprocessing - Post-processing from denoised ASVs only

# Import all required workflows and modules
import "workflows/demultiplex_amplicons.wdl" as DemultiplexAmpliconsWf
import "workflows/denoise_amplicons_1.wdl" as DenoiseAmplicons1Wf
import "workflows/denoise_amplicons_2.wdl" as DenoiseAmplicons2Wf
import "workflows/resistance_marker_module.wdl" as ResistanceMarkerModuleWf
import "workflows/quality_control.wdl" as QualityControlWf
import "workflows/process_inputs.wdl" as ProcessInputsWf
import "workflows/validate_inputs.wdl" as ValidateInputsWf
import "workflows/qc_only.wdl" as QcOnlyWf
import "workflows/postproc_only.wdl" as PostprocOnlyWf
import "modules/local/build_alleletable.wdl" as BuildAlleletable

## Main MAD4HatTeR workflow
workflow MAD4HatTeR {
  input {
    ## MANDATORY ARGUMENTS
    Array[String] pools

    # The sequencer used to produce your data [Options: miseq, nextseq]
    String sequencer

    ## WORKFLOW-SPECIFIC MANDATORY ARGUMENTS
    # List of fastqs. Must be in correct order.
    Array[File] left_fastqs
    Array[File] right_fastqs

    # Path to denoised ASVs from DADA2 (required for 'postprocessing' workflow only)
    File? denoised_asvs

    ## OPTIONAL ARGUMENTS
    # Workflow option to be run [Options: complete (default), qc, postprocessing]
    String workflow_type = "complete"

    # amplicon info files
    Array[File] amplicon_info

    ## DADA2 PARAMETERS
    # Level of statistical evidence required for DADA2 to infer a new ASV
    Float omega_a = 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001

    # Pooling method for DADA2 to process ASVs [Options: pseudo (default), true, false]
    String dada2_pool = "pseudo"

    # Limit on the net cumulative number of insertions of one sequence relative to the other in DADA2
    Int band_size = 16

    # Limit on number of expected errors within a read during filtering and trimming within DADA2
    Int maxEE = 3

    ## POST-PROCESSING PARAMETERS
    # Whether to concatenate or discard any sequences that DADA2 was unable to merge
    Boolean concat_non_overlaps = false

    # Path to targeted reference sequences (optional, auto-generated if not provided)
    File? refseq_fasta

    # Path to full genome covering all targets (optional)
    File? genome

    # The length a homopolymer must reach to be masked
    Int homopolymer_threshold = 5

    # The alignment score threshold for tandem repeat masking
    Int trf_min_score = 25

    # The maximum pattern size for tandem repeat masking
    Int trf_max_period = 3

    ## RESISTANCE MARKER MODULE PARAMETERS
    # Path to table of resistance marker info (auto-generated by pipeline if not provided)
    File? resmarker_info

    ## RUNTIME PARAMETERS
    # Docker image to use for all tasks
    String docker_image = "mad4hatter:latest"
  }

  # Validate inputs first - this ensures all required parameters are present and valid
  #TODO: This does not exist, create or add validation here.
  call ValidateInputsWf.validate_inputs {
    input:
      pools = pools,
      sequencer = sequencer,
      workflow_type = workflow_type,
      read_pairs = read_pairs,
      denoised_asvs = denoised_asvs,
      docker_image = docker_image
  }

  # Generate final amplicon info
  call ProcessInputsWf.generate_amplicon_info {
    input:
      pools = pools,
      docker_image = docker_image,
      amplicon_info = amplicon_info
  }

  # Branch workflow execution based on workflow_type parameter
  if (workflow_type == "qc") {
    ## QC ONLY WORKFLOW
    # Run quality control analysis only - useful for initial data assessment
    call QcOnlyWf.qc_only {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_file,
        left_fastqs = left_fastqs,
        right_fastqs = right_fastqs,
        docker_image = docker_image,
        sequencer = sequencer
    }
  }

  if (workflow_type == "postprocessing") {
    ## POST-PROCESSING ONLY WORKFLOW
    # Run post-processing from pre-existing denoised ASVs
    call PostprocOnlyWf.postproc_only {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        denoised_asvs = select_first([denoised_asvs]),
        refseq_fasta = refseq_fasta,
        genome = genome,
        homopolymer_threshold = homopolymer_threshold,
        trf_min_score = trf_min_score,
        trf_max_period = trf_max_period,
        resmarker_info = resmarker_info,
        docker_image = docker_image
    }
  }

  if (workflow_type == "complete") {
    ## COMPLETE WORKFLOW
    # Execute the full MAD4HatTeR pipeline from raw reads to final results

    # Step 1: Demultiplex amplicons by target region
    # This separates reads by amplicon target and performs initial quality filtering
    call DemultiplexAmpliconsWf.demultiplex_amplicons {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        left_fastqs = left_fastqs,
        right_fastqs = right_fastqs,
        sequencer = sequencer,
        docker_image = docker_image
    }

    # Step 2: First denoising step using DADA2
    # This performs error correction, dereplication, and initial ASV inference
    call DenoiseAmplicons1Wf.denoise_amplicons_1 {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        demultiplexed_fastqs = demultiplex_amplicons.demux_fastqs_ch,
        omega_a = omega_a,
        dada2_pool = dada2_pool,
        band_size = band_size,
        maxEE = maxEE,
        concat_non_overlaps = concat_non_overlaps,
        docker_image = docker_image
    }

    # Step 3: Second denoising step with masking and collapsing
    # This performs sequence masking, collapses similar ASVs, and creates final ASV table
    call DenoiseAmplicons2Wf.denoise_amplicons_2 {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        denoise_results = denoise_amplicons_1.denoise_ch,
        refseq_fasta = refseq_fasta,
        genome = genome,
        homopolymer_threshold = homopolymer_threshold,
        trf_min_score = trf_min_score,
        trf_max_period = trf_max_period,
        docker_image = docker_image
    }

    # Step 4: Build final allele table
    # This creates the comprehensive allele frequency table combining all samples and amplicons
    call BuildAlleletable.build_alleletable {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        denoise_results = denoise_amplicons_1.denoise_ch,
        masking_results = denoise_amplicons_2.results_ch,
        docker_image = docker_image
    }

    # Step 5: Generate quality control report
    # This creates comprehensive QC metrics and visualizations for the entire run
    call QualityControlWf.quality_control {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        sample_summary = demultiplex_amplicons.sample_summary_ch,
        amplicon_summary = demultiplex_amplicons.amplicon_summary_ch,
        allele_data = build_alleletable.alleledata,
        denoise_results = denoise_amplicons_1.denoise_ch,
        docker_image = docker_image
    }

    # Step 6: Resistance marker analysis
    # This identifies and analyzes known resistance markers in the final ASV data
    call ResistanceMarkerModuleWf.resistance_marker_module {
      input:
        amplicon_info = generate_amplicon_info.amplicon_info_ch,
        allele_data = build_alleletable.alleledata,
        aligned_asv_table = denoise_amplicons_2.aligned_asv_table,
        reference_sequences = denoise_amplicons_2.reference_ch,
        resmarker_info = resmarker_info,
        docker_image = docker_image
    }
  }

  ## OUTPUT DEFINITIONS
  output {
    # QC workflow outputs
    File? qc_report = qc_only.qc_report

    # Post-processing workflow outputs
    File? postproc_results = postproc_only.final_results

    # Complete workflow outputs
    File? final_allele_table = build_alleletable.alleledata
    File? quality_report = quality_control.quality_report
    File? resistance_analysis = resistance_marker_module.resistance_results
    File? sample_summary = demultiplex_amplicons.sample_summary_ch
    File? amplicon_summary = demultiplex_amplicons.amplicon_summary_ch
  }
}